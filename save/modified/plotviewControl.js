/*globals define, WebGMEGlobal*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Sat Nov 14 2020 23:50:23 GMT-0600 (Central Standard Time).
 */

define([
  "js/Constants",
  "js/Utils/GMEConcepts",
  "js/NodePropertyNames",
], function (CONSTANTS, GMEConcepts, nodePropertyNames) {
  "use strict";

  function PlotViewControl(options) {
    this._logger = options.logger.fork("Control");

    this._client = options.client;

    // Initialize core collections and variables
    this._widget = options.widget;

    this._currentNodeId = null;
    //this._currentNodeParentId = undefined;

    //this._initWidgetEventHandlers();

    this._logger.debug("ctor finished");
  }

  /*PlotViewControl.prototype._initWidgetEventHandlers = function () {
    this._widget.onNodeClick = function (id) {
      // Change the current active object
      WebGMEGlobal.State.registerActiveObject(id);
    };
  };*/

  /* * * * * * * * Visualizer content update callbacks * * * * * * * */
  // One major concept here is with managing the territory. The territory
  // defines the parts of the project that the visualizer is interested in
  // (this allows the browser to then only load those relevant parts).
  PlotViewControl.prototype.selectedObjectChanged = function (nodeId) {
    //var desc = this._getObjectDescriptor(nodeId),
    //  self = this;
    const node = this._client.getNode(nodeId);
    const self = this;

    self._logger.debug("activeObject nodeId '" + nodeId + "'");

    // Remove current territory patterns
    if (self._currentNodeId) {
      self._client.removeUI(self._territoryId);
    }

    self._currentNodeId = nodeId;
    //self._currentNodeParentId = undefined;

    if (typeof self._currentNodeId === "string") {
      // Put new node's info into territory rules
      self._selfPatterns = {};
      self._selfPatterns[nodeId] = { children: 0 }; // Territory "rule"

      if (node) {
        self._widget.setTitle(node.getAttribute("name"));
        //self._widget.setTitle("some element");
      } else {
        self._widget.setTitle("no element...");
      }

      //self._widget.setTitle(desc.name.toUpperCase());

      //self._widget.setTitle(desc.name.toUpperCase());

      /*if (typeof desc.parentId === "string") {
        self.$btnModelHierarchyUp.show();
      } else {
        self.$btnModelHierarchyUp.hide();
      }*/

      //self._currentNodeParentId = desc.parentId;

      self._territoryId = self._client.addUI(self, function (events) {
        self._eventCallback(events);
      });

      // Update the territory
      self._client.updateTerritory(self._territoryId, self._selfPatterns);

      //self._selfPatterns[nodeId] = { children: 1 };
      //self._client.updateTerritory(self._territoryId, self._selfPatterns);
    }
  };

  // This next function retrieves the relevant node information for the widget
  PlotViewControl.prototype._getObjectDescriptor = function (nodeId) {
    var node = this._client.getNode(nodeId),
      objDescriptor;
    if (node) {
      objDescriptor = {
        id: node.getId(),
        name: node.getAttribute(nodePropertyNames.Attributes.name),
        childrenIds: node.getChildrenIds(),
        parentId: node.getParentId(),
        isConnection: GMEConcepts.isConnection(nodeId),
      };

      /*const raw_data = JSON.parse(node.getAttribute("simRes") || "{}");
      for (let parameter in raw_data) {
        raw_data[parameter] = raw_data[parameter].map(parseFloat);
      }
      //if (raw_data.time) {
      for (let parameter in raw_data) {
        if (parameter != "time") {
          let paramDescriptor = {};
          paramDescriptor.name = parameter;
          paramDescriptor.x = raw_data.time;
          paramDescriptor.y = raw_data[parameter];
          paramDescriptor.mode = "lines";
          objDescriptor.push(paramDescriptor);
        }
      }
        
      return objDescriptor;
      } else {
        return null;
      }*/
    }

    return objDescriptor;
  };

  /* * * * * * * * Node Event Handling * * * * * * * */
  PlotViewControl.prototype._eventCallback = function (events) {
    var i = events ? events.length : 0,
      event;

    this._logger.debug("_eventCallback '" + i + "' items");

    while (i--) {
      event = events[i];
      switch (event.etype) {
        case CONSTANTS.TERRITORY_EVENT_LOAD:
        case CONSTANTS.TERRITORY_EVENT_UPDATE:
          this._onLoad(event.eid);
          break;

        case CONSTANTS.TERRITORY_EVENT_UNLOAD:
          this._widget.setTitle("element has been removed...");
          this._widget.plotData(null);
          //this._onUnload(event.eid);
          break;
        default:
          break;
      }
    }

    this._logger.debug("_eventCallback '" + events.length + "' items - DONE");
  };

  PlotViewControl.prototype._onLoad = function (gmeId) {
    var description = this._getObjectDescriptor(gmeId);
    this._widget.plotData(description);
  };

  /*PlotViewControl.prototype._onUpdate = function (gmeId) {
    var description = this._getObjectDescriptor(gmeId);
    //this._widget.updateNode(description);
  };

  PlotViewControl.prototype._onUnload = function (gmeId) {
    //this._widget.removeNode(gmeId);
  };*/

  PlotViewControl.prototype._stateActiveObjectChanged = function (
    model,
    activeObjectId
  ) {
    if (this._currentNodeId === activeObjectId) {
      // The same node selected as before - do not trigger
    } else {
      this.selectedObjectChanged(activeObjectId);
    }
  };

  /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
  PlotViewControl.prototype.destroy = function () {
    this._detachClientEventListeners();
    //this._removeToolbarItems();
  };

  PlotViewControl.prototype._attachClientEventListeners = function () {
    this._detachClientEventListeners();
    WebGMEGlobal.State.on(
      "change:" + CONSTANTS.STATE_ACTIVE_OBJECT,
      this._stateActiveObjectChanged,
      this
    );
  };

  PlotViewControl.prototype._detachClientEventListeners = function () {
    WebGMEGlobal.State.off(
      "change:" + CONSTANTS.STATE_ACTIVE_OBJECT,
      this._stateActiveObjectChanged
    );
  };

  PlotViewControl.prototype.onActivate = function () {
    this._attachClientEventListeners();
    //this._displayToolbarItems();

    if (typeof this._currentNodeId === "string") {
      WebGMEGlobal.State.registerActiveObject(this._currentNodeId, {
        suppressVisualizerFromNode: true,
      });
    }
  };

  PlotViewControl.prototype.onDeactivate = function () {
    this._detachClientEventListeners();
    //this._hideToolbarItems();
  };

  /* * * * * * * * * * Updating the toolbar * * * * * * * * * */

  return PlotViewControl;
});
